
==================== FINAL INTERFACE ====================
2016-12-21 21:52:48.259570063 UTC

interface clock-0.0.0-C2hzRbvtHFmH8t82fVkGG2:Clock 8001
  interface hash: b1bcddd986c52dd3d1a978dff5167652
  ABI hash: cecae813f70e7e5bf3d070aad16c7aca
  export-list hash: d6135a0684d80c9878ebfc35c8bd31ff
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: b159a15c55fa7c6870cb2eb79bbae5a5
  sig of: Nothing
  used TH splices: False
  where
exports:
  Clock.fromHourMin
  Clock.toString
  Clock.Clock|{clockHour clockMin}
module dependencies:
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:Data.Char eb33dc25ecb52d018a0ca26590e2b50b
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.0.0:GHC.Real 08bf4acb5f2508f89d6fbcd57fe232e9
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
5f117f001069847c60b7d0639cf015be
  $fShowClock :: GHC.Show.Show Clock.Clock
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Clock.Clock
                  Clock.$fShowClock_$cshowsPrec
                  Clock.toString
                  Clock.$fShowClock_$cshowList -}
f864582bda15a07a34dc664aa0874df3
  $fShowClock1 :: GHC.Prim.Int# -> GHC.Base.String
  {- Arity: 1,
     Unfolding: (\ (ww :: GHC.Prim.Int#)[OneShot] ->
                 case Clock.$wdigits ww of wild {
                   [] -> Clock.$fShowClock3
                   : x ds
                   -> case ds of wild1 {
                        []
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             Clock.$fShowClock2
                             (GHC.Types.:
                                @ GHC.Types.Char
                                (GHC.Show.intToDigit x)
                                (GHC.Types.[] @ GHC.Types.Char))
                        : ipv ipv1
                        -> GHC.Base.map
                             @ GHC.Types.Int
                             @ GHC.Types.Char
                             GHC.Show.intToDigit
                             wild } }) -}
477413d116f09a54ea98bba8849ff136
  $fShowClock2 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '0'#) -}
d16a2e9132e0086d8156fe93705c0dc5
  $fShowClock3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "00"#) -}
5f117f001069847c60b7d0639cf015be
  $fShowClock_$cshowList :: [Clock.Clock] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Clock.Clock]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Clock.Clock
                   (Clock.$fShowClock_$cshowsPrec GHC.Show.shows22)
                   ls
                   s) -}
5f117f001069847c60b7d0639cf015be
  $fShowClock_$cshowsPrec ::
    GHC.Types.Int -> Clock.Clock -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><L,U(1*U(U),1*U(U))><L,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Clock.Clock)
                   (w2 :: GHC.Base.String) ->
                 Clock.$w$cshowsPrec w1 w2) -}
5fc07fc1631caeb3967dc2d5ab3b2db3
  $tc'Time :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12104886464868553913##
                   11030706712984610060##
                   Clock.$trModule
                   Clock.$tc'Time1) -}
95d308725fde11c0543c42e3f3eb2b78
  $tc'Time1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Time"#) -}
12e1938f885d01383d5a95ba26909589
  $tcClock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2928480460030185111##
                   6841859362934353829##
                   Clock.$trModule
                   Clock.$trModule1) -}
82f355adc584c94a87e2b752800a9081
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Clock.$trModule2 Clock.$trModule1) -}
6406c90b3ae152fb5990eb91c510a380
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Clock"#) -}
00675b523cba91a82f318c03c973102c
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "clock-0.0.0-C2hzRbvtHFmH8t82fVkGG2"#) -}
5f117f001069847c60b7d0639cf015be
  $w$cshowsPrec :: Clock.Clock -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <L,U(1*U(U),1*U(U))><L,1*U>, Inline: [0],
     Unfolding: (\ (w :: Clock.Clock) (w1 :: GHC.Base.String) ->
                 case w of wild { Clock.Time ds ds1 ->
                 case ds of wild1 { GHC.Types.I# x ->
                 case GHC.Classes.modInt# x 12# of ww2 { DEFAULT ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (Clock.$fShowClock1 ww2)
                   (GHC.CString.unpackAppendCString#
                      ":"#
                      (case ds1 of wild2 { GHC.Types.I# x1 ->
                       case GHC.Classes.modInt# x1 60# of ww1 { DEFAULT ->
                       GHC.Base.++
                         @ GHC.Types.Char
                         (Clock.$fShowClock1 ww1)
                         w1 } })) } } }) -}
9e180dfb87cfa5fb663dc6b816474405
  $wdigits :: GHC.Prim.Int# -> [GHC.Types.Int]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
5f117f001069847c60b7d0639cf015be
  data Clock
    = Time {clockHour :: GHC.Types.Int, clockMin :: GHC.Types.Int}
0564019db37cd60e6c7baf082f973046
  clockHour :: Clock.Clock -> GHC.Types.Int
  RecSel Left Clock.Clock
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Clock.Clock) ->
                 case ds of wild { Clock.Time ds1 ds2 -> ds1 }) -}
3da615ffa360a0a0f04415c65c417578
  clockMin :: Clock.Clock -> GHC.Types.Int
  RecSel Left Clock.Clock
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Clock.Clock) ->
                 case ds of wild { Clock.Time ds1 ds2 -> ds2 }) -}
134585f5ce04f5ee388bb3716247e482
  fromHourMin :: GHC.Types.Int -> GHC.Types.Int -> Clock.Clock
  {- Arity: 2, Strictness: <B,A><B,A>x,
     Unfolding: InlineRule (2, True, True)
                (\ (h :: GHC.Types.Int) (m :: GHC.Types.Int) ->
                 Clock.fromHourMin1) -}
f9b61a56db1211d0835f9fd85b3a41e7
  fromHourMin1 :: Clock.Clock
  {- Strictness: x -}
5f117f001069847c60b7d0639cf015be
  toString :: Clock.Clock -> GHC.Base.String
  {- Arity: 1, Strictness: <L,U(1*U(U),1*U(U))>,
     Unfolding: (\ (c :: Clock.Clock) ->
                 case c of wild { Clock.Time ds ds1 ->
                 case ds of wild1 { GHC.Types.I# x ->
                 case GHC.Classes.modInt# x 12# of ww2 { DEFAULT ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (Clock.$fShowClock1 ww2)
                   (GHC.CString.unpackAppendCString#
                      ":"#
                      (case ds1 of wild2 { GHC.Types.I# x1 ->
                       case GHC.Classes.modInt# x1 60# of ww1 { DEFAULT ->
                       Clock.$fShowClock1 ww1 } })) } } }) -}
instance [safe] GHC.Show.Show [Clock.Clock] = Clock.$fShowClock
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

